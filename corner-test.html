<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Corner Icon Color Test</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, sans-serif;
      background: #8B7355;
      min-height: 200vh;
    }

    /* Vignette */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
      background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.8) 100%);
      transition: opacity 0.25s ease-out;
    }

    body.flash::before {
      opacity: 0;
    }

    /* Content card */
    .content {
      position: relative;
      z-index: 1;
      max-width: 800px;
      margin: 100px auto;
      padding: 40px;
      background: rgba(255, 248, 212, 0.95);
      border-radius: 8px;
    }

    .content h2 {
      color: #56a2c4;
      margin-bottom: 20px;
    }

    .content p {
      color: #333;
      line-height: 1.7;
      margin-bottom: 16px;
    }

    /* Corner symbols */
    .corner-symbol {
      position: fixed;
      font-family: monospace;
      font-size: 1.5rem;
      color: #d8d0a8;
      z-index: 100;
      cursor: pointer;
      user-select: none;
      transition: transform 0.15s ease-out, color 0.15s ease-out;
    }

    .corner-symbol:hover {
      transform: scale(1.3);
      color: #56a2c4;
    }

    .corner-symbol:active {
      transform: scale(1.1);
    }

    .corner-top-left { top: 1rem; left: 1rem; }
    .corner-top-right { top: 1rem; right: 1rem; }
    .corner-bottom-left { bottom: 1rem; left: 1rem; }
    .corner-bottom-right { bottom: 1rem; right: 1rem; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <span class="corner-symbol corner-top-left" data-corner="saturn">♄</span>
  <span class="corner-symbol corner-top-right" data-corner="jupiter">♃</span>
  <span class="corner-symbol corner-bottom-left" data-corner="sun">☉</span>
  <span class="corner-symbol corner-bottom-right" data-corner="moon">☽</span>

  <div class="content">
    <h2>Corner Icon Color Test</h2>
    <p>Click any corner symbol to trigger a color flash effect. Each symbol has its own color palette.</p>
    <p>The vignette fades out, colors shift to primaries, jitter flows, then everything settles back to normal.</p>
    <p>Scroll to test the normal jitter behavior.</p>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    canvas.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      pointer-events: none;
    `;

    // Color palettes for each corner - each introduces 2 contrasting primaries
    const palettes = {
      normal: ['#6B5344', '#8B7355', '#9E8B7D', '#56a2c4'],
      saturn: ['#ff0000', '#cc0000', '#0000ff', '#0000cc'],   // Red + Blue
      jupiter: ['#ffff00', '#cccc00', '#00ff00', '#00cc00'],  // Yellow + Green
      sun: ['#ff6600', '#ff3300', '#00ffff', '#00cccc'],      // Orange + Cyan
      moon: ['#ff00ff', '#cc00cc', '#ffff00', '#cccc00']      // Magenta + Yellow
    };

    // Settings
    let settings = {
      jitterAmount: 0.47,
      scrollSensitivity: 5.0,
      settleSpeed: 0.38,
      blueTop: 10,
      blueBottom: 32,
      colors: [...palettes.normal]
    };

    // State
    let baseImageData = null;
    let currentImageData = null;
    let scrollVelocity = 0;
    let lastScrollY = 0;
    let isJittering = false;
    let flashVelocity = 0;  // Extra velocity from corner clicks

    // Color animation state
    let currentColors = palettes.normal.map(hexToRgb);
    let targetColors = palettes.normal.map(hexToRgb);
    let colorLerpSpeed = 0.08;  // How fast colors transition
    let residueAmount = 0.10;   // How much color remains after settling (10%)
    let lastClickedPalette = null;  // Track which palette to leave residue from

    function hexToRgb(hex) {
      return {
        r: parseInt(hex.slice(1, 3), 16),
        g: parseInt(hex.slice(3, 5), 16),
        b: parseInt(hex.slice(5, 7), 16)
      };
    }

    function lerpColor(a, b, t) {
      return {
        r: Math.round(a.r + (b.r - a.r) * t),
        g: Math.round(a.g + (b.g - a.g) * t),
        b: Math.round(a.b + (b.b - a.b) * t)
      };
    }

    // Blend two palettes: (1-t)*paletteA + t*paletteB
    function blendPalettes(paletteA, paletteB, t) {
      return paletteA.map((colorA, i) => lerpColor(colorA, paletteB[i], t));
    }

    function updateColors() {
      let needsUpdate = false;
      for (let i = 0; i < currentColors.length; i++) {
        const curr = currentColors[i];
        const target = targetColors[i];
        const dr = Math.abs(curr.r - target.r);
        const dg = Math.abs(curr.g - target.g);
        const db = Math.abs(curr.b - target.b);

        if (dr > 2 || dg > 2 || db > 2) {
          currentColors[i] = lerpColor(curr, target, colorLerpSpeed);
          needsUpdate = true;
        } else if (dr > 0 || dg > 0 || db > 0) {
          // Snap to target when close
          currentColors[i] = { r: target.r, g: target.g, b: target.b };
        }
      }
      return needsUpdate;
    }

    function getBlueAmount() {
      const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
      const scrollProgress = scrollHeight > 0 ? window.scrollY / scrollHeight : 0;
      return settings.blueTop + (settings.blueBottom - settings.blueTop) * scrollProgress;
    }

    function generateBaseNoise() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      baseImageData = ctx.createImageData(canvas.width, canvas.height);
      const data = baseImageData.data;
      const blueThreshold = 1 - (getBlueAmount() / 100);

      for (let i = 0; i < data.length; i += 4) {
        const rand = Math.random();
        let color;
        if (rand < 0.35) {
          color = currentColors[0];
        } else if (rand < 0.65) {
          color = currentColors[1];
        } else if (rand < blueThreshold) {
          color = currentColors[2];
        } else {
          color = currentColors[3];
        }
        data[i] = color.r;
        data[i + 1] = color.g;
        data[i + 2] = color.b;
        data[i + 3] = 255;
      }

      currentImageData = new ImageData(
        new Uint8ClampedArray(baseImageData.data),
        canvas.width,
        canvas.height
      );
      ctx.putImageData(currentImageData, 0, 0);
    }

    function applyJitter(intensity) {
      const data = currentImageData.data;
      const baseData = baseImageData.data;
      const blueThreshold = 1 - (getBlueAmount() / 100);

      for (let i = 0; i < data.length; i += 4) {
        if (Math.random() < intensity) {
          const rand = Math.random();
          let color;
          if (rand < 0.35) {
            color = currentColors[0];
          } else if (rand < 0.65) {
            color = currentColors[1];
          } else if (rand < blueThreshold) {
            color = currentColors[2];
          } else {
            color = currentColors[3];
          }
          data[i] = color.r;
          data[i + 1] = color.g;
          data[i + 2] = color.b;
        } else if (Math.random() < settings.settleSpeed * 0.5) {
          data[i] = baseData[i];
          data[i + 1] = baseData[i + 1];
          data[i + 2] = baseData[i + 2];
        }
      }
      ctx.putImageData(currentImageData, 0, 0);
    }

    function animate() {
      const currentScrollY = window.scrollY;
      const deltaScroll = Math.abs(currentScrollY - lastScrollY);
      lastScrollY = currentScrollY;

      const velocityDecay = 1 - settings.settleSpeed;
      scrollVelocity = scrollVelocity * velocityDecay + deltaScroll * settings.scrollSensitivity * 0.1;

      // Add flash velocity (decays faster)
      flashVelocity = flashVelocity * 0.85;

      // Update color lerping (colors apply through jitter, not regeneration)
      updateColors();

      const totalVelocity = scrollVelocity + flashVelocity;
      const jitterIntensity = Math.min(totalVelocity * settings.jitterAmount, 0.5);

      if (jitterIntensity > 0.001 || totalVelocity > 0.1) {
        applyJitter(jitterIntensity);
        isJittering = true;
      } else if (isJittering) {
        applyJitter(0);
        if (totalVelocity < 0.01) {
          isJittering = false;
        }
      }

      requestAnimationFrame(animate);
    }

    // Corner click handler
    function triggerFlash(cornerName) {
      const palette = palettes[cornerName] || palettes.normal;
      const paletteRgb = palette.map(hexToRgb);
      const normalRgb = palettes.normal.map(hexToRgb);

      // Store which palette we're using for residue
      lastClickedPalette = paletteRgb;

      // Set colors to flash palette immediately (full intensity)
      currentColors = paletteRgb.map(c => ({...c}));
      targetColors = paletteRgb.map(c => ({...c}));

      // Add vignette flash class
      document.body.classList.add('flash');

      // Trigger jitter burst
      flashVelocity = 8;

      // Animate back to residue blend after delay
      setTimeout(() => {
        // Set colors to residue blend
        const residueColors = blendPalettes(normalRgb, paletteRgb, residueAmount);
        currentColors = residueColors.map(c => ({...c}));
        targetColors = residueColors.map(c => ({...c}));

        // Regenerate base noise with residue colors so settling uses them
        generateBaseNoise();

        document.body.classList.remove('flash');
        // Jitter burst to show the transition
        flashVelocity = 4;
      }, 500);
    }

    // Initialize
    function init() {
      generateBaseNoise();
      animate();

      window.addEventListener('resize', generateBaseNoise);

      let lastScrollForBlue = 0;
      window.addEventListener('scroll', () => {
        if (Math.abs(window.scrollY - lastScrollForBlue) > 50) {
          lastScrollForBlue = window.scrollY;
          generateBaseNoise();
        }
      });

      // Corner click listeners
      document.querySelectorAll('.corner-symbol').forEach(el => {
        el.addEventListener('click', () => {
          triggerFlash(el.dataset.corner);
        });
      });
    }

    init();
  </script>
</body>
</html>
